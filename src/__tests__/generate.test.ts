import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { generate } from '../generate';
import * as fsPromises from 'fs/promises';
import { downloadFile } from '../download';
import { jest, expect } from '@jest/globals';

// Simple mock setup
const mockDownloadFile = jest.fn<(url: string) => Promise<string>>();
jest.mock(
  '../download',
  () => ({
    downloadFile: mockDownloadFile,
  }),
  { virtual: true },
);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('Generate Tests', () => {
  const testDir = path.join(__dirname, '../../test-output');

  beforeEach(() => {
    mockDownloadFile.mockReset();
  });

  beforeAll(() => {
    fs.mkdirSync(testDir, { recursive: true });
  });

  afterAll(() => {
    fs.rmSync(testDir, { recursive: true });
  });

  it('should generate workflow files', async () => {
    // Mock responses for all file types with basic header
    mockDownloadFile.mockImplementation(async (url) => {
      return `/* This file is auto-generated by Vysta. Do not edit directly. */`;
    });

    await generate('http://localhost:8080', testDir);

    // Verify files were created with header comment
    const workflowsPath = path.join(testDir, 'workflows.ts');
    const result = await fsPromises.readFile(workflowsPath, 'utf8');
    
    // Check only for header comment
    expect(result).toContain('This file is auto-generated by Vysta');
  });
});
